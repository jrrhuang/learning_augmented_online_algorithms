from . import AbstractAlgorithm, OMSThresholdFunction

import numpy as np

class OneMaxSearchAlgorithm(AbstractAlgorithm):
    def __init__(self, L, U, lmbda, predictor=None):
        """
        Initialize threshold function used to determine resource allocation at
        each time step. Starting resource amount (w) is set to 0.0, with 1.0 as
        the maximum. Can use predictions from predictor, which should implement
        the abstract_predictory.py class.
        """
        if predictor is None and lmbda < 1.0:
            raise ValueError("if no predictor, can only use lmbda == 1.0")

        # threshold function used in OneMaxSearch
        self.threshold = OMSThresholdFunction(L, U, lmbda)
        self.predictor = predictor
        # resource utilization amount set to zero
        self.w = 0.0

    def allocate(self, instance):
        """
        Runs algorithm on an instance of data, allocating resources to maximize
        profit.

        Arguments:
        instance : pd.Series
            - array of time-series prices, for example, one week of BTC prices

        Returns: result (dictionary)
        - result['allocation'] : list showing allocation at each time step, should
            sum up to 1.0, the total amount allowed to be allocated
        - result['profit'] : profit generated by the algorithm
        """        
        allocation_idx = -1
        # iterate over exchange rate in the time-series data
        for i in range(len(instance)):
            if self.predictor is not None:
                prediction = self.predictor.predict(instance)
                reservation_price = self.threshold(self.w, prediction)
            else:
                # prediction will not be used in threshold calculation
                reservation_price = self.threshold(self.w, np.NINF)

            # allocate if instance is greater than reservation price
            #  and resource utilization is still zero
            if instance[i] >= reservation_price and self.w <= 1e-5:
                allocation_idx = i
                self.w = 1.0 # all resources are utilized
                break # allocation is only oneshot - we are done

        # if nothing is allocated as in the paper, we are stuck with
        #  the last price, where allocation_idx is -1
        allocation = np.zeros(shape=(len(instance),), dtype=np.float32)
        allocation[allocation_idx] = 1.0

        result = {}
        result['allocation'] = allocation
        result['profit'] = np.sum(instance * allocation)

        return result
